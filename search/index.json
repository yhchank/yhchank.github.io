[{"content":"\n","date":"2023-01-31T08:19:26+08:00","permalink":"https://yhchank.github.io/p/%E4%B8%80%E5%9B%BE%E6%A6%82%E8%BF%B0%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","title":"一图概述树状数组"},{"content":"图论要素：通向权重（ch）环 通：是否连通\n向：是否有向\n权：是否带权，点权/边权，是否为01权\n重：是否有重边\n环：是否有环，是否有自环\n*关于最短路： 无权图：BFS\n正权图：\n稠密图：普通 Dijkstra，$\\Theta(V^2)$\n稀疏图：堆优化 Dijkstra，$\\Theta(E \\log E)$\n带副权的图：SPFA\n","date":"2022-12-31T08:08:12+08:00","permalink":"https://yhchank.github.io/p/%E5%9B%BE%E8%AE%BA%E8%A6%81%E7%B4%A0/","title":"图论要素"},{"content":"\n","date":"2022-12-11T08:32:15+08:00","permalink":"https://yhchank.github.io/p/elf%E6%A0%BC%E5%BC%8F%E6%A6%82%E8%BF%B0/","title":"ELF格式概述"},{"content":"概述 解决的问题 无修改的离线区间询问问题\n对问题的要求 假设 $n$ 为下标范围，$m$ 为询问次数，若从 $[l, r]$ 的答案能够以某种方式（假设一次转移的复杂度为$\\Theta(x)$）扩展到 $[l - 1, r], [l + 1, r], [l, r + 1], [l, r - 1]$的答案，那么所有询问可以使用莫队算法在 $\\Theta((n + m) \\sqrt{n} \\cdot x)$ 的时间内求出\n实现 简易版本 流程 离线后排序（左端点 $l$ 为第一关键字，右端点 $r$ 为第二关键字） 设置初始位置：$l = 1, r = 0, now = 0 (now为当前答案)$ 顺序处理每个询问 代码 注：此代码以统计区间不同数字个数为例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 struct Query { int l, r; int id, ans; }; int n, m; int a[MAXN]; Query q[MAXQ]; int cnt[MAXN]; int l, r, ans; bool cmpRG(const Query \u0026amp;_a, const Query \u0026amp;_b) { // 左端点为第一关键字，右端点为第二关键字 if(_a.l != _b.l) { return _a.l \u0026lt; _b.l; } else { return _a.r \u0026lt; _b.r; } } bool cmpID(const Query \u0026amp;_a, const Query \u0026amp;_b) { // id return _a.id \u0026lt; _b.id; } void add(int x) { // 向区间添加元素，更新当前答案 cnt[a[x]]++; if(cnt[a[x]] == 1) { ans++; } } void del(int x) { // 从区间删除元素，更新答案 cnt[a[x]]--; if(cnt[a[x]] == 0) { ans--; } } int main() { // Code here... for(int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; q[i].l \u0026gt;\u0026gt; q[i].r; q[i].id = i; } sort(q + 1, q + m + 1, cmpRG); // 对区间排序 l = 1; // 初始位置 r = 0; ans = 0; for(int i = 1; i \u0026lt;= m; i++) { while(r \u0026gt; q[i].r) { // 移动到新区间 del(r--); } while(r \u0026lt; q[i].r) { add(++r); } while(l \u0026gt; q[i].l) { add(--l); } while(l \u0026lt; q[i].l) { del(l++); } q[i].ans = ans; } sort(q + 1, q + m + 1, cmpID); // 恢复原顺序 // Code here... } 优化 过程 可以发现，在最劣的情况下，比如询问的区间为 $[1, 1], [1, 50], [1, 100], [2, 2], [2, 50], [2, 100], [3, 3], [3, 50], [3, 100]$ 时，左端点只会移动 $3$ 次，但是右端点会移动大约 $300$ 次\n但是，如果对其按如下方式排序，移动次数就会大大降低\n$$ [1, 1], [2, 2], [3, 3], [1, 50], [2, 50], [3, 50], [1, 100], [2, 100], [3, 100] $$\n此时左端点大约会移动 $10$ 次，而右端点则会移动 $100$ 次\n这只是一个极端情况，对于普遍的情况，莫涛大神则提出了一种基于分块的方法：\n将下标范围 $[1, n]$ 分为 $\\sqrt{n}$ 块（$[1, \\sqrt{n}], [\\sqrt{n} + 1, 2\\sqrt{n}] \\dots$） 以区间左端点所在的块的编号为第一关键字，以右端点为第二关键字对所有询问区间排序 设置初始位置并顺序处理每个询问（同上） 这样，对于每一个块中的询问（此处询问所在的块即指询问左端点所在的块），右端点的移动范围都是 $n$（因为同一块内询问右端点有序，最多只会从下标 $1$ 移到下标 $n$），所以右端点移动的总复杂度为 $\\Theta(n\\sqrt{n})$（总共有 $\\sqrt{n}$ 个块）；而对于左端点，如果在块内移动，那么范围就是 $\\sqrt{n}$，如果在块间移动，那么范围至多也不超过 $\\Theta(2\\sqrt{n})$（移动到下一个区间），所以左端点移动的总复杂度为 $\\Theta(m\\sqrt{n})$（每次移动都是 $\\Theta{\\sqrt{n}}$）\n所以，算法总复杂度为 $\\Theta((n + m) \\sqrt{n})$，如果算上每次移动的复杂度为 $\\Theta(x)$，则总复杂度为 $\\Theta((n + m) \\sqrt{n} \\cdot x)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 struct Query { int l, r; int id, ans; }; int n, m; int a[MAXN]; Query q[MAXQ]; int cnt[MAXN]; int l, r, ans; int block; bool cmpRG(const Query \u0026amp;_a, const Query \u0026amp;_b) { // 左端点为第一关键字，右端点为第二关键字 if(_a.l / block != _b.l / block) { return _a.l \u0026lt; _b.l; } else { return _a.r \u0026lt; _b.r; } } bool cmpID(const Query \u0026amp;_a, const Query \u0026amp;_b) { // id return _a.id \u0026lt; _b.id; } void add(int x) { // 向区间添加元素，更新当前答案 cnt[a[x]]++; if(cnt[a[x]] == 1) { ans++; } } void del(int x) { // 从区间删除元素，更新答案 cnt[a[x]]--; if(cnt[a[x]] == 0) { ans--; } } int main() { // Code here... block = sqrt(n); for(int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; q[i].l \u0026gt;\u0026gt; q[i].r; q[i].id = i; } sort(q + 1, q + m + 1, cmpRG); // 对区间排序 l = 1; // 初始位置 r = 0; ans = 0; for(int i = 1; i \u0026lt;= m; i++) { while(r \u0026gt; q[i].r) { // 移动到新区间 del(r--); } while(r \u0026lt; q[i].r) { add(++r); } while(l \u0026gt; q[i].l) { add(--l); } while(l \u0026lt; q[i].l) { del(l++); } q[i].ans = ans; } sort(q + 1, q + m + 1, cmpID); // 恢复原顺序 // Code here... } 再优化（蛇形移动） 可以发现，每次从一个块前往下一个块的时候，左端点常常会移动很远，此时，我们可以利用蛇形移动来优化。\n我们先将左端点和右端点在坐标系中形象地表示出来：\n所谓蛇形移动，就是对于奇数块和偶数块在块内采用相反的方向按右端点排序。这样，每次解决完一个块时，我们不必使左端点回到头部，所以可以节省部分时间。\n当然，这种方法通常是常数级优化。\n具体实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 struct Query { int l, r; int lid; // 左端点所在的块的编号 int id, ans; }; int n, m; int a[MAXN]; Query q[MAXQ]; int cnt[MAXN]; int l, r, ans; int block; bool cmpRG(const Query \u0026amp;_a, const Query \u0026amp;_b) { // 左端点为第一关键字，右端点为第二关键字 if(_a.lid != _b.lid) { return _a.lid \u0026lt; _b.lid; } else { if(_a.lid % 2) { // 奇数块 return _a.r \u0026lt; _b.r; // 升序排列 } else { // 偶数块 return _a.r \u0026gt; _b.r; // 降序排列 } } } bool cmpID(const Query \u0026amp;_a, const Query \u0026amp;_b) { // id return _a.id \u0026lt; _b.id; } void add(int x) { // 向区间添加元素，更新当前答案 cnt[a[x]]++; if(cnt[a[x]] == 1) { ans++; } } void del(int x) { // 从区间删除元素，更新答案 cnt[a[x]]--; if(cnt[a[x]] == 0) { ans--; } } int main() { // Code here... block = sqrt(n); for(int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; q[i].l \u0026gt;\u0026gt; q[i].r; q[i].lid = q[i].l / block; q[i].id = i; } sort(q + 1, q + m + 1, cmpRG); // 对区间排序 l = 1; // 初始位置 r = 0; ans = 0; for(int i = 1; i \u0026lt;= m; i++) { while(r \u0026gt; q[i].r) { // 移动到新区间 del(r--); } while(r \u0026lt; q[i].r) { add(++r); } while(l \u0026gt; q[i].l) { add(--l); } while(l \u0026lt; q[i].l) { del(l++); } q[i].ans = ans; } sort(q + 1, q + m + 1, cmpID); // 恢复原顺序 // Code here... } ","date":"2022-10-04T09:29:54+08:00","permalink":"https://yhchank.github.io/p/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E8%8E%AB%E9%98%9F/","title":"【算法笔记】莫队"},{"content":"局部调整法 调整+分析 假设优劣+建立不等式 解不等式 得到局部调整结论 得到贪心策略 ","date":"2022-10-04T09:28:59+08:00","permalink":"https://yhchank.github.io/p/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%B1%80%E9%83%A8%E8%B0%83%E6%95%B4%E6%B3%95/","title":"【算法笔记】局部调整法"},{"content":"ST表 处理的问题 RMQ： 区间最值问题\n适用情况 一次初始化（$\\Theta(n \\log n)$），$q$次询问（$q$极大，每次$\\Theta(1)$）\n流程 倍增思想预处理出每个以i为左边界，长度为2的j次方的区间最值 $\\Theta(1)$查询 模版（以max举例） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int lg[MAXN]; int st[MAXN][35]; void init_lg() { // 初始化log值 for(int i = 2; i \u0026lt;= n; i++) { lg[i] = lg[i \u0026gt;\u0026gt; 1] + 1; } } void init_st() { // 初始化st表 for(int i = n; i \u0026gt;= 1; i--) { st[i] = a[i]; for(int k = 1; i + (1 \u0026lt;\u0026lt; k) \u0026lt;= n; i++) { st[i][k] = max(st[i][k - 1], st[i + (1 \u0026lt;\u0026lt; (k - 1))][k - 1]); } } } void st_q(int l, int r) { // 区间查询 int s = lg[r - l + 1]; return max(st[l][s], st[r - (1 \u0026lt;\u0026lt; s) + 1][s]); } 可以使用ST表的问题 只有可重复贡献问题可以使用ST表，所谓可重复贡献问题，是指满足x opt x == x的操作opt\n注意点 第一层循环一定是for(int i = n; i \u0026gt;= 1; i--)，方向不能错\n","date":"2022-09-12T18:42:17+08:00","permalink":"https://yhchank.github.io/p/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0st%E8%A1%A8/","title":"【算法笔记】ST表"},{"content":" 前往谷歌的浏览器策略页面，链接：https://support.google.com/chrome/a/answer/187202?hl=zh-Hans\n点击Windows选项，选择包含 Google Chrome 模板和文档的 Zip 文件并下载\n打开policy_templates.zip，将windows\\admx\\chrome.admx复制到C:\\Windows\\PolicyDefinitions\\，并将windows\\admx\\zh-CN\\chrome.adml复制到C:\\Windows\\PolicyDefinitions\\zh-CN\\\n启动gpedit.msc\n打开计算机配置\\管理模板\\Google Chrome\\\n找到无痕模式的可用性，双击打开\n选择已启用并在下面的菜单中选择隐身模式已停用，点击确定\n关闭组策略编辑器，现在已经无法启动无痕浏览模式\n**注：如需禁用Microsoft Edge（新版）**的无痕浏览模式，可到此处下载策略文件并配置\n","date":"2022-09-04T19:57:19+08:00","permalink":"https://yhchank.github.io/p/google-chrome-%E5%A6%82%E4%BD%95%E7%A6%81%E7%94%A8%E6%97%A0%E7%97%95%E6%B5%8F%E8%A7%88%E6%A8%A1%E5%BC%8F/","title":"Google Chrome 如何禁用无痕浏览模式"},{"content":"解决方法：\n打开fiddler-tools-options-https\n取消勾选decrypt https traffic\n点击actions-remove interception certficates ，删除所有证书\n重新勾选decrypt https traffic，根据提示安装证书\n","date":"2022-08-30T21:45:49+08:00","permalink":"https://yhchank.github.io/p/%E5%90%AF%E7%94%A8fiddler%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","title":"启用Fiddler导致无法联网的解决方法"},{"content":"题面 点这里\n分析 可以先回忆一下我们平时是如何通分的（以样例#2为例）。\n首先，把分母全部乘起来：\n$$\\frac{1}{3^1}+\\frac{1}{3^2}+\\frac{1}{3^3}=\\frac{3^2 \\times 3^3+3^1 \\times 3^3+3^1 \\times 3^2}{3^1 \\times 3^2 \\times 3^3}$$\n把指数加起来，得到：\n$$\\frac{3^5+3^4+3^3}{3^6}$$\n显然，分子和分母上的任意一个数都是 $3^n$，也就是说：我们只需要找到分子中次数最低的一项（$3^3$）去跟分母（$3^6$）比较，输出其中次数更低的一项（$3^3$）即可。\n稍作观察即可得到答案的公式：$ans = \\min(sum - a_i)$（其中 $sum$ 表示所有 $a_i$ 的和）。\n但是，看到样例一，这里出现了两个 $2$，根据 $ans = \\min(sum - a_i)$，此时的答案应为 $2^2=4$，但是实际答案为 $8$。\n为什么？显然是因为 $2^2+2^2=2 \\times 2^2=2^3$（只看分母），也就是说，当 $a_i$ 有重复时，要把每个值的个数也考虑进去，比如说，$12$ 个 $2^2$ 就应该写成 $3 \\times 2^4$。\n所以我们可以统计每个 ${sum - a_i}$ 的值的出现次数，然后计算出现次数中有几个因数 $x$，可以用这样一个函数来实现：\n1 2 3 4 5 6 7 8 int count(int a, int \u0026amp;b) { // 计算b中有几个因数a，用“\u0026amp;b”是因为处理完后b剩余的数还要用到 int res = 0; while (b \u0026amp;\u0026amp; b % a == 0) { // 如果b大于0且还有因数a res++; // 个数加一 b /= a; // 除掉因数a } return res; } 但是，如果你这样写，还是会 WA，因为有可能出现这样的情况： $2^2 \\times 8 + 2^3 \\times 4 = 2^2 \\times 2^3 + 2^3 \\times 2^2 = 2^5 + 2^5 = 2 ^ 6$。也就是说，即使考虑了每个 ${sum - a_i}$ 的值的出现次数，在计算的过程中，还是有可能出现重复的情况。\n对于这个问题，我的解决办法：\n首先，开一个 Number 类型（定义见下方）的优先队列。\n1 2 3 4 5 6 7 8 9 10 struct Number { int k; // x的k次方 int cnt; // 有cnt个 bool operator\u0026gt;(const Number \u0026amp;_x) const { // 重载大于运算符，优先队列中会用到 return k \u0026gt; _x.k; } }; priority_queue\u0026lt;Number, vector\u0026lt;Number\u0026gt;, greater\u0026lt;Number\u0026gt;\u0026gt; q; 在输入完成后，先预处理出每个 $sum - a_i$，放在 $b$ 数组中，代码如下：\n1 2 3 4 5 6 7 int sum = 0; for (int i = 1; i \u0026lt;= n; i++) { // 计算a[i]的和 sum += a[i]; } for (int i = 1; i \u0026lt;= n; i++) { // 预处理出每个sum - a[i]的值 b[i] = sum - a[i]; } 然后，统计每个 $b_i$ 值的个数，一起 push 到优先队列里：\n1 2 3 4 5 6 7 8 9 10 int tmp = 1; b[0] = -1; for (int i = n - 1; i \u0026gt;= 0; i--) { // 倒着统计（其实正向也可以） if (b[i] != b[i + 1]) { // 把sum - a[i]（即b[i]）的值和它的个数一起push到单调队列里 q.push({b[i + 1], tmp}); tmp = 0; // 清除计数器 } tmp++; // 计数器加一 } 每次取出次数最小的数并不断检查剩下的队首元素，如果次数和当前元素的次数相同，那么就合并 cnt 最后，调用上文提到的 count() 函数来处理 $b_i$值的个数，并把结果乘到当前元素上，把 count() 处理完的 cnt （也就是不能再拆出 $x$ 了）最为新的 cnt，然后重新加入队列；注意： 如果 count() 函数的返回值为 $0$ ，则意味着 cnt 中已经拆不出来因数 $x$ 了，所以此时的答案就是当前元素的次数，可以直接 break，代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 while (!q.empty()) { Number f = q.top(); // 每次取出次数最小的数 q.pop(); while (!q.empty() \u0026amp;\u0026amp; q.top().k == f.k) { // 如果队首元素的次数和当前元素的次数相同 f.cnt += q.top().cnt; // 合并个数 q.pop(); } ans = f.k; // 更新答案 int tmp = count(x, f.cnt); // 计算cnt中能拆出开的因数x的个数 if (tmp) { // k加上处理结果，剩下拆不掉的数仍然作为cnt q.push({f.k + tmp, f.cnt}); } else { // cnt中拆不出来因数x了，可以直接结束 break; } } 由于分子的结果可能比分母的次数高，还需要取一下最小值：\n1 ans = min(ans, sum); 最后用快速幂算出 $x^{ans}$ 即可。\n完整代码 最然看起来很长，其实内容并不多。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 /* *\tAuthor: Hank Yu *\tProblem: CF359C *\tDate: 2022/08/16 */ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; void faster_io() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); } #define int long long #define MAXN 100005 #define MOD 1000000007 struct Number { int k; // x的k次方 int cnt; // 有cnt个 bool operator\u0026gt;(const Number \u0026amp;_x) const { // 重载大于运算符，优先队列中会用到 return k \u0026gt; _x.k; } }; int n, x; int a[MAXN]; int b[MAXN]; priority_queue\u0026lt;Number, vector\u0026lt;Number\u0026gt;, greater\u0026lt;Number\u0026gt;\u0026gt; q; int count(int a, int \u0026amp;b) { // 计算b中有几个因数a int res = 0; while (b \u0026amp;\u0026amp; b % a == 0) { // 如果b大于0且还有因数a res++; // 个数加一 b /= a; // 除掉因数a } return res; } int qpow(int x, int k, int q) { // 快速幂模板 int ans = 1; while (k \u0026gt; 1) { if (k % 2 == 1) { ans *= x; ans %= q; } x *= x; x %= q; k /= 2; } if (k == 1) { ans *= x; ans %= q; } return ans; } signed main() { faster_io(); // cin/cout加速 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x; for (int i = 1; i \u0026lt;= n; i++) { // 输入 cin \u0026gt;\u0026gt; a[i]; } int sum = 0; for (int i = 1; i \u0026lt;= n; i++) { // 计算a[i]的和 sum += a[i]; } for (int i = 1; i \u0026lt;= n; i++) { // 预处理出每个sum - a[i]的值 b[i] = sum - a[i]; } { // 防止变量名污染 int tmp = 1; b[0] = -1; for (int i = n - 1; i \u0026gt;= 0; i--) { // 倒着统计（其实正向也可以） if (b[i] != b[i + 1]) { // 把sum - a[i]（即b[i]）的值和它的个数一起push到单调队列里 q.push({b[i + 1], tmp}); tmp = 0; // 清除计数器 } tmp++; // 计数器加一 } } int ans = 0; { // 防止变量名污染 while (!q.empty()) { Number f = q.top(); // 每次取出次数最小的数 q.pop(); while (!q.empty() \u0026amp;\u0026amp; q.top().k == f.k) { // 如果队首元素的次数和当前元素的次数相同 f.cnt += q.top().cnt; // 合并个数 q.pop(); } ans = f.k; // 更新答案 int tmp = count(x, f.cnt); // 计算cnt中能拆出开的因数x的个数 if (tmp) { // k加上处理结果，剩下拆不掉的数仍然作为cnt q.push({f.k + tmp, f.cnt}); } else { // cnt中拆不出来因数x了，可以直接结束 break; } } } ans = min(ans, sum); // 由于分子的结果可能比分母的次数高，这里需要取最小值 cout \u0026lt;\u0026lt; qpow(x, ans, MOD) \u0026lt;\u0026lt; endl; } AC ","date":"2022-08-17T10:36:30+08:00","permalink":"https://yhchank.github.io/p/cf359c-%E9%A2%98%E8%A7%A3/","title":"CF359C 题解"},{"content":"朴素算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void dijkstra() { for (int i = 1; i \u0026lt;= n; i++) { int mink = 0; for (int j = 1; j \u0026lt;= n; j++) { if (!vis[j] \u0026amp;\u0026amp; d[j] \u0026lt;= d[mink]) { mink = j; } } vis[mink] = true; for (Edge \u0026amp;e : g[mink]) { if (d[mink] \u0026lt; d[e.v] \u0026amp;\u0026amp; d[mink] + e.w \u0026lt; d[e.v]) { d[e.v] = d[mink] + e.w; } } } } 堆优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void dijkstra() { while (!q.empty()) { int x = q.top().id; q.pop(); if (!vis[x]) { vis[x] = true; for (Edge \u0026amp;e : g[x]) { if (d[e.v] \u0026gt; d[x] + e.w) { d[e.v] = d[x] + e.w; if (!vis[e.v]) { q.push({e.v, d[e.v]}); } } } } } } ","date":"2022-08-09T21:06:28+08:00","permalink":"https://yhchank.github.io/p/%E6%A8%A1%E6%9D%BFdijkstra%E7%AE%97%E6%B3%95/","title":"【模板】Dijkstra算法"},{"content":"PS：如果您只需要Bellman-Ford/SPFA/判负环模板，请到相应的模板部分 上一篇中简单讲解了用于多源最短路的Floyd算法。本篇要介绍的则是用于单源最短路的Bellman-Ford算法和它的一些优化（已死的SPFA）\nBellman-Ford算法 其实，和Floyd算法类似，Bellman-Ford算法同样是基于DP思想的，而且也是在不断的进行松弛操作（可以理解为「不断放宽对结果的要求」，比如在Floyd中就体现为不断第一维$k$，具体解释在这里)\n既然是单源最短路径问题，我们就不再需要在DP状态中指定起始点。于是，我们可以设计出这样的DP状态（和Floyd很类似）：\n$$dp[k][u]表示从s（起点）到u，最多经过k条边时的最短路径$$\n显然，初始值为：\n$$对于起点s，dp[0][s]=0；对于其他任意节点u，dp[0][u]=+\\infin$$\n我们可以先考虑，如何从$dp[0][u]$转移出$dp[1][u]$（就是多一条边）。\n于是很容易想到这个最显而易见又最暴力的方法：枚举每一条边$(u, v)$，并更新$dp[1][v]=min(dp[1][v], dp[0][u]+w[u][v])（其中w[u][v]表示这条边的边权）$\n推广到任意$dp[k-1][u]$到$dp[k][u]$的转移，我们仍然可以使用这样的方法。\n下面是代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 struct Edge { int u, v; // 边的两个端点 int w; // 边的权值 }; int n; // 点数 int m; // 边数 Edge e[MAXM]; // 所有的边 int dp[MAXN][MAXN]; // 解释见上方 void bellman_ford(int start) { memset(dp, 0x3f, sizeof(dp)); // 初始化为INF dp[0][start] = 0; for(int i = 1; i \u0026lt; n; i++) { // 一张图中的最长路径最多只包含n - 1边，所以更新n - 1遍就够了（因为点不能重复） for(int j = 1; j \u0026lt;= n; j++) { // 先复制一遍 dp[i][j] = dp[i - 1][j]; } for(int j = 1; j \u0026lt;= m; j++) { // 枚举每一条边 dp[i][e[j].v] = min(dp[i][e[j].v], dp[i - 1][e[j].u] + e[j].w); } } } 显然，时间复杂度为$O(nm)$，空间复杂度也是$O(nm)$，代码复杂度为O(1)。\n我们可以先考虑优化空间复杂度（压缩掉第一维$k$），于是，DP状态变为：\n$$dp[u]表示从s（起点）到u的最短路径$$\n转移方程为：\n$$dp[v]=min(dp[v],dp[u]+w[v])$$\n关于状态压缩后的正确性：最有可能令人不理解的部分就是：在同一轮更新中，我们可能会用已经更新完的值再去更新别的值。这就导致，同一论更新中，不同节点被更新到的DP值对应的$k$可能不同。（如果没看懂，就看下面这张图）\n但是实际上，我们其实并不关心到底走了几步，而只关心最短路的边权和。所以，像这样的“错位更新”并不会引起错误。\n于是，我们可以得到新的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct Edge { int u, v; // 边的两个端点 int w; // 边的权值 }; int n; // 点数 int m; // 边数 Edge e[MAXM]; // 所有的边 int dp[MAXN]; // 解释见上方 void bellman_ford(int start) { memset(dp, 0x3f, sizeof(dp)); // 初始化为INF dp[start] = 0; for(int i = 1; i \u0026lt; n; i++) { // 一张图中的最长路径最多只包含n - 1边，所以更新n - 1遍就够了（因为点不能重复） for(int j = 1; j \u0026lt;= m; j++) { // 枚举每一条边 dp[e[j].v] = min(dp[e[j].v], dp[e[j].u] + e[j].w); } } } 我们可以继续考虑优化时间复杂度。显然，如果在某一轮的更新后，发现并没有任何一个值被更新，那么就意味着：这张图已经不能再被更新了（已经求出$s$到每个点的最短路），那就可以直接break了。\n所以，优化后的代码如下：\nBellman-Ford算法模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 struct Edge { int v; // 边指向的节点 int w; // 边的权值 }; int n; // 点数 int m; // 边数 vector\u0026lt;Edge\u0026gt; g[MAXN]; // 保存从每个节点发出的边 int dp[MAXN]; // 解释见上方 void bellman_ford(int start) { memset(dp, 0x3f, sizeof(dp)); // 初始化为INF dp[start] = 0; for(int i = 1; i \u0026lt; n; i++) { // 一张图中的最长路径最多只包含n - 1边，所以更新n - 1遍就够了（因为点不能重复） bool updated = 0; // 记录是否有节点被更新 for(int i = 1; i \u0026lt;= n; i++) { // 枚举每一个节点 if(dp[i] == 0x3f3f3f3f) { // 无法到达的节点 continue; } for(Edge \u0026amp;e : g[i]) { // 枚举从这个节点发出的每一条边 if(dp[i] + e.w \u0026lt; dp[e.v]) { dp[e.v] = dp[i] + e.w; updated = 1; // 标记有值被更新 } } } if(!updated) { break; // 没有节点被更新，直接退出 } } } 这就是最常见的Bellman-Ford朴素算法了。\n同时，也可以看到，本次优化后的代码中将「直接储存所有边」的方式改为了使用「邻接表」。这是因为邻接表在图论算法中更加常用，也使得Bellman-Ford算法可以更容易地和其他算法配合使用。\nSPFA算法 SPFA算法（Shortest Path Faster Algorithm），顾名思义就是一种让Bellman-Ford跑得更快的方法。\n在上一部分的最后，我们对于没有更新的情况，直接break掉，来优化时间。但是，稍加思考就会发现：有的时候，我们会为了唯一几个被更新过的节点，而再把所有的节点遍历一遍，那么这样就会产生时间的浪费。所以，SPFA本质上就是使用队列来解决这样的问题。\n下面是SPFA算法的基本步骤：\n我们先设置好初始值（和Bellman-Ford一样），再将起点（$s$）加入队列中。\n每次从队列中取出一个节点，尝试用它去更新与它相连的节点；如果某个节点的最短距离被更新了，那么将这个节点加入队列。\n回到步骤2\n于是，很容易写出对应的代码：\nSPFA算法模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 struct Edge { int v; // 边指向的节点 int w; // 边的权值 }; int n; // 点数 int m; // 边数 vector\u0026lt;Edge\u0026gt; g[MAXN]; // 保存从每个节点发出的边 int dp[MAXN]; // 定义没有变 queue\u0026lt;int\u0026gt; q; // 储存点用的队列 bool vis[MAXN]; // 记录每个节点当前是否在队列中 void spfa(int start) { memset(dp, 0x3f, sizeof(dp)); // 初始化为INF dp[start] = 0; q.push(start); vis[start] = 1; // 标记一下 while(!q.empty()) { int x = q.front(); // 取出一个节点 q.pop(); vis[x] = 0; // 清除标记，因为下次还有可能入队 for(Edge \u0026amp;e : g[x]) { // 枚举从这个节点发出的每一条边 if(dp[x] + e.w \u0026lt; dp[e.v]) { dp[e.v] = dp[x] + e.w; if(!vis[e.v]) { // 如果这个节点现在不在队列中 q.push(e.v); // 那就把它加入队列 vis[e.v] = 1; // 标记一下 } } } } } 一道测试用的例题：P4779 【模板】单源最短路径（标准版）（因为SPFA已死，所以会TLE。。。）\nBellman-Ford \u0026amp; SPFA判断负环 负环，就是边权和为负数的环。负环是最短路算法中一个很重要的问题，因为只要进入一个负环，最短距离就会无限减小。当然，这肯定不是我们希望的，所以接下来就要介绍如何使用Bellman-Ford算法或SPFA算法来判断一张图中是否包含负环。\n显然，一张有向图上的任意一条简单路径最多只包含$n-1$条边（否则不可能是 简单 的）。而且，当图中没有负环时，两点间的最短路径一定是简单路径。所以，如果发现从起点到某个节点$u$的最短路径包含多于$n-1$条边，那么这条路径上一定包含负环。\n所以，我们只需要在算法中添加一些简单的判断就可以实现判负环了。\n具体方法：\n对于普通的Bellman_ford算法，我们可以在完成DP后，在进行一遍更新，如果存在任意节点与起点之间的最短路径是可以被更新的，那么可以确定图中一定存在负环\n对于SPFA算法，我们可以在更新最短路径的同时，记录每条最短路径上的边数，如果发现某条最短路径的边数大于$n-1$，那么可以确定图中一定存在负环\n于是，我们可以写出分别使用这两种算法来判负环的代码：\nBellman-Ford判负环模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 struct Edge { int v; // 边指向的节点 int w; // 边的权值 }; int n; // 点数 int m; // 边数 vector\u0026lt;Edge\u0026gt; g[MAXN]; // 保存从每个节点发出的边 int dp[MAXN]; bool bellman_ford_check_ncycle(int start) { memset(dp, 0x3f, sizeof(dp)); // 初始化为INF dp[start] = 0; for(int i = 1; i \u0026lt; n; i++) { // 一张图中的最长路径最多只包含n - 1边，所以更新n - 1遍就够了（因为点不能重复） bool updated = 0; // 记录是否有节点被更新 for(int i = 1; i \u0026lt;= n; i++) { // 枚举每一个节点 if(dp[i] == 0x3f3f3f3f) { // 无法到达的节点 continue; } for(Edge \u0026amp;e : g[i]) { // 枚举从这个节点发出的每一条边 if(dp[i] + e.w \u0026lt; dp[e.v]) { dp[e.v] = dp[i] + e.w; updated = 1; // 标记有值被更新 } } } if(!updated) { return 0; // 没有节点被更新，一定没有负环 } } for(int i = 1; i \u0026lt;= n; i++) { // 枚举每一个节点 if(dp[i] == 0x3f3f3f3f) { // 无法到达的节点 continue; } for(Edge \u0026amp;e : g[i]) { // 枚举从这个节点发出的每一条边 if(dp[i] + e.w \u0026lt; dp[e.v]) { return 1; // 还能被更新说明有负环 } } } return 0; } SPFA判负环模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 struct Edge { int v; // 边指向的节点 int w; // 边的权值 }; int n; // 点数 int m; // 边数 vector\u0026lt;Edge\u0026gt; g[MAXN]; // 保存从每个节点发出的边 int dp[MAXN]; // dp的定义没有变 int cnt[MAXN]; // 记录从起点到节点u的最短路径中的边数 queue\u0026lt;int\u0026gt; q; // 储存点用的队列 bool vis[MAXN]; // 记录每个节点当前是否在队列中 bool spfa_check_ncycle(int start) { // SPFA判负环 memset(dp, 0x3f, sizeof(dp)); // 初始化为INF dp[start] = 0; q.push(start); vis[start] = 1; // 标记一下 while(!q.empty()) { int x = q.front(); // 取出一个节点 q.pop(); vis[x] = 0; // 清除标记，因为下次还有可能入队 for(Edge \u0026amp;e : g[x]) { // 枚举从这个节点发出的每一条边 if(dp[x] + e.w \u0026lt; dp[e.v]) { dp[e.v] = dp[x] + e.w; cnt[e.v] = cnt[e.v] + 1; // 多了当前这条边 if(cnt[e.v] \u0026gt;= n) { // 从起点到v的最短路径上有多于n - 1条边 return 1; // 一定出现了负环 } if(!vis[e.v]) { // 如果这个节点现在不在队列中 q.push(e.v); // 那就把它加入队列 vis[e.v] = 1; // 标记一下 } } } } return 0; // 没有负环 } 一道测试用的例题：P3385 【模板】负环\n","date":"2022-08-09T20:22:51+08:00","permalink":"https://yhchank.github.io/p/bellman-ford%E7%AE%97%E6%B3%95%E4%B8%8Espfa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/","title":"Bellman-Ford算法与SPFA算法详解"},{"content":"Floyd本质上使用了DP思想，我们定义$d[k][x][y]$为允许经过前k个节点时，节点x与节点y之间的最短路径长度，显然初始值应该为$d[k][x][y] = +\\infin (k, x, y\\in[1, n])$；对于有边直接连接的两点$x$和$y$，$d[k][x][y] = 边长$。\n转移方程：$f[k][x][y] = min{f[k - 1][x][y], f[k - 1][x][k] + f[k - 1][k][y]}$\n考虑状态压缩，显然$f[k][x][k]$是一定等于$f[k - 1][x][k]$，因为$x$到$k$的路径不可能以点$k$本身为中转节点；同理，$f[k][k][y] = f[k - 1][k][y]$。\n于是，我们可以直接压缩掉第一维（$k$），新的状态为$d[x][y]$（$x$和$y$两点的最短路径长度），转移方程为$f[x][y] = min{f[x][y], f[x][k] + f[k][y]}$\n代码实现：\n1 2 3 4 5 6 7 for(int k = 1; k \u0026lt;= n; k++) { for(int i = 1; i \u0026lt;= n; i++) { for(int j = 1; j \u0026lt;= n; j++) { d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } } } Floyd的思想其实就是“通过逐步引入新的中继节点，来计算对应节点/状态间的最优路径”。在标准的Floyd算法中，“最优路径”指的就是最短路，但实际上，Floyd算法还可以解决一些其他的问题.\n比如这道题（洛谷P2888），我们根据Floyd的基本思想，就可以设计出转移方程$f[x][y] = min{f[x][y], max{f[x][k] + f[k][y]}}$\n具体实现（其实就只改了转移方程）：\n1 2 3 4 5 6 7 for(int k = 1; k \u0026lt;= n; k++) { for(int i = 1; i \u0026lt;= n; i++) { for(int j = 1; j \u0026lt;= n; j++) { d[i][j] = min(d[i][j], max(d[i][k], d[k][j])); } } } Updated on 2022/8/7 关于Floyd思想的另一种应用 其实Floyd还可以处理支持传递闭包的问题。\n集体实现：\n1 2 3 4 5 6 7 8 for(int k = 1; k \u0026lt;= n; k++) { for(int i = 1; i \u0026lt;= n; i++) { for(int j = 1; j \u0026lt;= n; j++) { d[i][j] |= d[i][k] \u0026amp; d[k][j]; // 只要d[i][k]和d[k][j]都能满足，那么d[i][j]也能满足 } } } 直接上例子：CF500B New Year Permutation\n这道题中，数组中「元素的交换」就支持传递闭包，即：若a和b可以交换，b和c也可以交换，那么a和c就一定可以通过b来间接交换。所以，我们也可以使用Floyd算法来解决。\nUpdated on 2022/8/10 再附上Floyd求最小环的模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 int ans = 0x1f1f1f1f; for(int k = 1; k \u0026lt;= n; k++) { for(int i = 1; i \u0026lt;= n; i++) { for(int j = i + 1; j \u0026lt;= n; j++) { ans = min(ans, d[i][j] + w[i][k] + w[k][j]); } } for(int i = 1; i \u0026lt;= n; i++) { for(int j = 1; j \u0026lt;= n; j++) { d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } } } ","date":"2022-08-06T15:47:58+08:00","permalink":"https://yhchank.github.io/p/floyd%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/","title":"Floyd算法详解"},{"content":"二叉树的递归定义如下：二叉树要么为空，要么由根节点、左子树、右子树组成，而左子树和右子树分别是一棵二叉树。在计算机中，树一般是“倒置”的，即根在上，叶子在下。\n树和二叉树类似，区别在于没一个节点不一定只有两棵子树。\n图示： 不管是二叉树还是树，每个非根节点都有一个父亲，也成父节点。\n以下是一道例题\nUVa679: Dropping Balls 题目 UVA679 Dropping Balls\n分析 可以发现，对于一个结点k，其左子节点、右子结点的编号分别为2k和2k+1。\n因为小球落下后，开关的状态就会改变，所以一个节点上的小球的去向，跟这个小球是第几个到达此节点有关系，也就是说，如果是第奇数个到达，会往左走，偶数个，会往右走。\n如果是节点1，第一个小球（I=1）肯定会往左走，第二个小球（I=2）则会往右走。如果是节点2、3、4……，也会有和结点1类似的规律。比如第5颗球，他是第五个到达节点1的球，接下来往左，第5/2+1=3（奇）个到达节点2的球，接下来往左，3/2+1=2（偶），第2个到达节点4，下面第2/2=1个到达节点9；\n也就是说，球到达每个节点的编号决定了它下一步的方向，所以，我们只需要模拟最后一颗球，就可以得到结果。\n参考程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; const int maxd = 20; int s[1 \u0026lt;\u0026lt; maxd]; int main() { int D, I; while(scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;D, \u0026amp;I) == 2) { int k = 1; for(int i = 0; i \u0026lt; D - 1; i++) { if(I % 2) { k = k * 2; I = (I + 1) / 2; } else { k = k * 2 + 1; I = I / 2; } } printf(\u0026#34;%d\\n\u0026#34;, k); } return 0; } ","date":"2022-07-25T16:06:41+08:00","permalink":"https://yhchank.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"数据结构--树和二叉树"},{"content":"链表是一种物理存储单元上非连续、非顺序的存储结构。链表由一系列结点（链表中每一个元素称为结点）组成，每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。\n优点： 使用链表结构不需要预先知道数据大小，可以充分利用计算机内存空间，实现灵活的内存动态管理，链表还允许插入和移除表上任意位置上的节点。\n缺点： 链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。\n分类： 单向链表，双向链表以及循环链表\n图示： 以下是一道例题\nUVa11988：悲剧文本 题目 You’re typing a long text with a broken keyboard. Well it’s not so badly broken. The only problem with the keyboard is that sometimes the “home” key or the “end” key gets automatically pressed (internally). You’re not aware of this issue, since you’re focusing on the text and did not even turn on the monitor! After you finished typing, you can see a text on the screen (if you turn on the monitor). In Chinese, we can call it Beiju. Your task is to find the Beiju text. Input There are several test cases. Each test case is a single line containing at least one and at most 100,000 letters, underscores and two special characters ‘[’ and ‘]’. ‘[’ means the “Home” key is pressed internally, and ‘]’ means the “End” key is pressed internally. The input is terminated by end-of-file (EOF). The size of input file does not exceed 5MB. Output For each case, print the Beiju text on the screen.\n翻译 你在用坏了的键盘打一个长文本。嗯，它没那么坏。键盘的唯一问题是，有时会自动按下“home”键或“end”键。\n你没有意识到这个问题，因为你专注于文本，甚至没有打开显示器！输入完毕后，您可以在屏幕上看到文本（如果您打开显示器）。\n在中文里，我们可以叫它悲剧。你的任务是找到这段悲剧文本。\n输入\n有几组测试数据。每个测试用例是一行，包含至少一个且最多100000个字母、下划线和两个特殊字符“[”和“]”。“[”表示内部按下“Home”键，“]”表示内部按下“End”键。输入在文件末尾（EOF）终止。输入文件的大小不超过5MB。\n输出\n对于每组数据，在屏幕上打印悲剧文本。\n分析 用一个next数组表示每一个字符的下一项，比如第一个字符s[1]的下一个是s[2]，则next[1]=2。为了方便起见，我们还可以在链表的第一个元素前放一个虚拟节点，从第一个下标开始储存数据。\n我们可以设置一个光标cur，代表着位置i的字符应该插入在cur的右侧。程序运行时，cur有时会跳至左端即cur=0；有时要回到右端，所以还需要开一个last变量保存最右端的下标，使cur能通过cur=last跳回右端。\n参考程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int maxn = 100000 + 5; int last, cur; char s[maxn]; int next[maxn]; int main() { while(scanf(\u0026#34;%s\u0026#34;, s + 1) == 1) { //输入 int n = strlen(s + 1); last = 0; cur = 0; next[0] = 0; for(int i = 1; i \u0026lt;= n; i++) { char c = s[i]; if(c == \u0026#39;[\u0026#39;) { cur = 0; } else if(c == \u0026#39;]\u0026#39;) { cur = last; } else { //插入c next[i] = next[cur]; next[cur] = i; if(cur == last) { last = i; //更新最后字符的编号 } cur = i; //移动光标 } } for(int i = next[0]; i != 0; i = next[i]) { printf(\u0026#34;%c\u0026#34;, s[i]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } ","date":"2022-07-25T16:05:23+08:00","permalink":"https://yhchank.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8/","title":"数据结构--链表"},{"content":"P1980 计数问题 题目描述 试计算在区间 1 到 n的所有整数中，数字x(0 ≤ x ≤ 9)共出现了多少次？例如，在 1到11中，即在 1,2,3,4,5,6,7,8,9,10,11中，数字1出现了4次。\n输入格式 2个整数n,x，之间用一个空格隔开。\n输出格式 1个整数，表示x出现的次数。\n输入输出样例 输入 #1\n1 11 1 输出 #1\n1 4 题解 string to_string (int val);\nstring to_string (double val);\n这是C++11新增的库函数，已重载各种标准类型，用法很简单，例如 string s = to_string(123);\n但是对于大量数据只能一个数一个数转换，颇为繁琐\n还有一种方法就是 stringstream (使用stringstream 需包含头文件 ）\nint a = 123, b = 456, c = 789;\nstringstream ss;\nss \u0026laquo; a \u0026laquo; b \u0026laquo; c;\n以上几行把a b c三个变量读入字符串流中，这样就可以把a b c三个变量无缝衔接起来，但是需要注意的是，stringstream型不能直接输出，也不支持迭代器，需要利用stringstream类的成员函数str()才能把它当成普通字符串来用，例如\nstring s = ss.str();\n而把字符串转为数值的话也是用stringstream，例如上面的ss就可以转换为一个int型\nint i;\nss \u0026raquo; i;\n以上都是C++的方法，c语言有sprintf和sscanf，对应stringstream字符串流的读和写，\u0026lt;stdlib.h\u0026gt;中还有数值与字符串相互转换的iota和atoi函数，感兴趣的可以自己去了解。用c语言的sprintf比C++的字符串流效率高，但是我还是想用C++的字符串，为啥？因为C++字符串的可拓展性和灵活性比较高嘛hhhh\ncount函数，位于 头文件中\ncount(ivec.begin() , ivec.end() , searchValue)\n这个函数作用是统计在一定范围内某一值出现的次数\n前两个参数为起始位置和结束位置，都是迭代器，第三个参数为需要统计的值\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, x; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x; stringstream ss; for(; n \u0026gt;= 1; n--) { ss \u0026lt;\u0026lt; n; } string s = ss.str(); cout \u0026lt;\u0026lt; count(s.begin(), s.end(), x + \u0026#39;0\u0026#39;); return 0; } ","date":"2022-07-25T16:03:29+08:00","permalink":"https://yhchank.github.io/p/p1980-%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98-%E9%A2%98%E8%A7%A3/","title":"P1980 计数问题 - 题解"},{"content":"P4715 淘汰赛 题目描述 有 2^n (n≤7) 个国家参加世界杯决赛圈且进入淘汰赛环节。我经知道各个国家的能力值，且都不相等。能力值高的国家和能力值低的国家踢比赛时高者获胜。1 号国家和 2 号国家踢一场比赛，胜者晋级。3 号国家和 4 号国家也踢一场，胜者晋级……晋级后的国家用相同的方法继续完成赛程，直到决出冠军。给出各个国家的能力值，请问亚军是哪个国家？\n工具 队列，二叉树\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; int n; int num[130] = {}; queue\u0026lt;int\u0026gt; ids; int main() { cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= (2 \u0026lt;\u0026lt; (n - 1)); i++) { cin \u0026gt;\u0026gt; num[i]; ids.push(i); } while(ids.size() \u0026gt; 2) { int a = ids.front(); ids.pop(); int b = ids.front(); ids.pop(); int maxid = ((num[a] \u0026gt; num[b]) ? a : b); ids.push(maxid); } int a = ids.front(); ids.pop(); int b = ids.front(); ids.pop(); cout \u0026lt;\u0026lt; ((num[a] \u0026lt; num[b]) ? a : b); return 0; } ","date":"2022-07-25T16:02:53+08:00","permalink":"https://yhchank.github.io/p/p4715-%E6%B7%98%E6%B1%B0%E8%B5%9B-%E9%A2%98%E8%A7%A3/","title":"P4715 淘汰赛 - 题解"},{"content":"分析 我们不妨把这些座位看作是一张图中的节点，把每个人的诉求作为一条边（由【原座位】指向【想去的座位】）\n比如，对于样例#1，我们就可以得到这样一张图：\n显然，我们有可能会得到多个连通图（比如上面这张）\n因为每个座位上的人都只有一个想去的座位，所以每个点的出度就是 $0$（可能只有其他的点指向它） 或 $1$，整每个连通图的边数就是 $n$ （点的个数）或者 $n - 1$ 个\n当边数等于 $n$ 时，显然这是一个环或者一棵基环树（定义见这里）\n我们以这组数据举例：\n1 2 3 4 5 6 7 8 7 1 2 2 4 3 2 4 1 5 3 6 3 7 6 手画一下复制到Graph Editor，可以得到这张图：\n试着移动每一个点，容易发现：移动r任意环外点（比如这里的 $3$、$5$、$6$、$7$），环上的点肯定就没位置了。\n证明（废话） ：点 $2$ 唯一的一条出边已经用在环上了，所以 $2$ 和任意环外点之间的边一定是指向 $2$ 的，以此类推，我们可以发现：$3$、$5$、$6$、$7$ 对应的边都是指向 $2$ 的。于是，只要移动必定会移到 $2$ 的位置\n于是我们就可以得到结论：如果这是一棵基环树或者一个环，那么它的答案为 $2$（环内的点移/不移，两种情况）\n当边数等于 $n$ 时，显然这是一棵树\n我们拿它举例：\n每个节点的出度都为 $1$ 或 $0$（只可能有一个点出度为 $0$，这个座位一开始就空着），所以我们可以将唯一的那个出度为 $0$ 的点（如这张图中的点 $0$）作为树根。\n显然，我们移动任意一个点，都会导致一种确定且不重复的情况（它到根节点的链上的每一个点都往上移），所以其答案为 $n$，即点数\n于是，最终的答案就是将每个连通图的答案乘起来。\nHowTo 我们现在需要一种方法，可以判环、可以记录每个连通图的大小。\n显然，并查集很合适。\n每输入一个人的要求，我们就把这两个点所在的集合（连通图）合并（merge函数），同时记录集合大小（sz数组）。如果合并前这两个点已经在同一个集合中，那么，这一定是一个环（两点之间有不止一条路径），做一下标记。\n最后，统计答案即可。\n你以为结束了？\n还有一个坑。。。\n出现自环时，不能向上面那样考虑，因为这一个点移动后还在原来的位置，所以答案是 $1$（最终ans不变）\n细节请看代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long // 好习惯：随时开long long #define MAXN 200005 #define MOD 1000000007 // 记得取模 int n; int fa[MAXN]; // 并查集 - 父节点 int sz[MAXN]; // 并查集 - 集合大小 bool ish[MAXN]; // is环（记录此集合是否有环） bool iszh[MAXN]; // is自环 void init(int x) { // 并查集 - 初始化 for (int i = 1; i \u0026lt;= x; i++) { fa[i] = i; sz[i] = 1; // 初始大小都是1 } } int find(int x) { // 并查集 - 查找 if (fa[x] == x) { return x; } else { return fa[x] = find(fa[x]); } } void merge(int x, int y) { // 并查集 - 合并 int fx = find(x); int fy = find(y); if (fx == fy) { // 已经在同一个集合 return; } iszh[fy] |= iszh[fx]; // 合并自环信息 sz[fy] += sz[fx]; // 合并大小 fa[fx] = fy; } signed main() { cin \u0026gt;\u0026gt; n; init(n * 2); // 初始化 for (int i = 1; i \u0026lt;= n; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if (a == b) { iszh[find(a)] = 1; // 标记当前集合含有自环 } if (find(a) == find(b)) { // 已经在同一个集合了 ish[find(a)] = 1; // 标记当前集合含有环 } merge(a, b); // 连接这两个座位 } int ans = 1; for (int i = 1; i \u0026lt;= n * 2; i++) { if (find(i) == i) { // i是一个集合的代表 if (ish[i]) { // 含有环 if (iszh[i]) { // 自环，答案不变 continue; } ans *= 2; ans %= MOD; } else { // 不含有环 ans *= sz[i]; ans %= MOD; } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } AC ","date":"2022-07-25T11:20:58+08:00","permalink":"https://yhchank.github.io/p/cf859e-%E9%A2%98%E8%A7%A3/","title":"CF859E 题解"},{"content":" 原文链接：https://101001011.github.io/2022/06/11/zhi-ccf-de-yi-feng-gong-kai-xin/ 原文作者：CCA（CCA\u0026rsquo;s Blog）\n前天，我看到 CCF 发布了这样一则公告 ：\n得知此事，我很愤怒，但愤怒过后是深深的失落。大概是因为看着我所热爱的信息学竞赛正因为一个组织的糊涂行为走向毁灭吧。\n是的，毁灭。“ OI 要做干净的竞赛。” 这句话的提出者正抬起脚，狠狠地将这块令所有信息竞赛生引以为傲的招牌踩在地上，变得四分五裂。当一个竞赛已经失去了信用，那它的存在倒比毁灭更令人难过了。\n在过去的很多年里，CCF 一直有一个规定，若某省存在选手作弊，那么扣除该省省队名额一个，并将作弊选手禁赛三年。由于这个政策的存在，有很多本该进入省队的选手因为某个与自己毫不相关的人作弊而与自己本该获得的奖牌失之交臂。\n但这项规则对所有人都是如此吗？去年南门口中学某谢姓选手在省选考场上作弊，并进入省队。作弊事实败露后他仅仅是被 CCF 以非公开的方式取消了抄袭题目的分数，甚至还参加了在省选之后举办的清华集训。\n而今年情况越发严峻，十多个省由于存在作弊选手而被扣除省队名额，其中大多数为入门组的小朋友，而代价却要能够进入省队的高水平选手来承担。幸好后来事情发生了变化，有一名被判定为作弊的选手来自某超级强校，而那所学校的教练对 CCF 的行为进行了强烈的抗议，直接促使 CCF 被迫取消此规定。\n在结果大快人心的同时，我们不妨想想，之前难道没有学校对这个规定进行过抗议吗？为什么 CCF 可以置若罔闻，而超级强校对其抗议却立刻奏效了呢？\n在 CCF 取消上述规定后，我本来以为风波已平，却不想是另一场风暴的开端，而这次更是带来了席卷 OI 界的滔天巨浪 —— 某些选手因为在代码注释中写下 F**k_CCF 等内容而被取消本次考试成绩并被禁赛一年。\n先对一些关键点进行解释 ：\n代码注释是形如下文中 \" // \" 后面的内容 ： Copyvoid read (int \u0026amp;x) { x = 0; char c = getchar(); while (c \u0026lt; '0' || c \u0026gt; '9') c = getchar(); while (c \u0026gt;= '0' \u0026amp;\u0026amp; c \u0026lt;= '9') x = x * 10 + c - 48, c = getchar(); } // 这段代码被用来快速读入一个数\u0026lt;span class=\"bd-box\"\u0026gt;\u0026lt;h-char class=\"bd bd-beg\"\u0026gt;\u0026lt;h-inner\u0026gt;，\u0026lt;/h-inner\u0026gt;\u0026lt;/h-char\u0026gt;\u0026lt;/span\u0026gt;注意\u0026lt;span class=\"bd-box\"\u0026gt;\u0026lt;h-char class=\"bd bd-beg\"\u0026gt;\u0026lt;h-inner\u0026gt;，\u0026lt;/h-inner\u0026gt;\u0026lt;/h-char\u0026gt;\u0026lt;/span\u0026gt;只能用来读取不大于 2^31 - 1 的正整数\u0026lt;span class=\"bd-box\"\u0026gt;\u0026lt;h-char class=\"bd bd-beg\"\u0026gt;\u0026lt;h-inner\u0026gt;。\u0026lt;/h-inner\u0026gt;\u0026lt;/h-char\u0026gt;\u0026lt;/span\u0026gt; 注释一般被写在代码中用来提醒程序员这段代码起什么作用或者需要注意什么事情，在评测时机器不会读取这些字符。\n在 OI 考试中，时间紧，任务重，大多数选手在考试结束时是拿不到自己的极限分数的。而在考试中，题目质量，考场状态，考试策略等都能极大地影响一个选手的分数，但一场考试又最多只有 4 道题，所以选手在在看到自己不擅长的题目类型时是非常难受的。比如说这次 NOIp，我本人在发现有一半题目是 DP 题，并且 DP 又是我最不擅长的知识点时，花 5 分钟去厕所洗了个脸才基本冷静下来。而某些选手在注释中写下一些对 CCF 的怒斥又何尝不是他们宣泄情绪，让自己保持冷静的方式呢 ？ 至于某些人将这种行为类比成在高考作文中骂教育部是完全不恰当的，因为在了解了 OI 的规则后，我们知道这种行为顶多算是在草稿纸上写 F**k jyb. 改卷老师（评测机）是不会看到这些语句的。虽然草稿纸最后会被公示（此处不得不承认 CCF 在赛后公示选手代码（答卷）是考试史上的一大进步），但公示后会看到的人数至多以千记，造成的影响不算很大。\n禁赛一年是指在接下来的一年中，被禁赛的选手将不能参加所有 NOI 系列的比赛，这意味着一个选手不能参加次年的 NOIp，而又有谁能在不参加 NOIp 的情况下进入省队呢？所以一个选手两年内的所有比赛将会被禁止，这意味着如果这个选手是高中生，那么他的 OI 之路必将就此断绝。 回归正题。看到这里，大家对 CCF 的行为应该已经有了自己的评判。我想，大多数 OIer 对 CCF 所作行为的愤怒之处并不在于他对涉事选手的处罚，而在于 ：\n选手不过是在 “草稿纸” 上骂了 CCF 几句，而 CCF 却要对他们赶尽杀绝，这未免已经超出了批评教育，甚至惩罚的范畴。\n前 IOI 中国代表队成员钟子谦已经对全国选手的代码进行了查找，发现在代码中辱骂 CCF 者高达 122 人之多，而 CCF 却只处罚了 5 名高水平选手，仅占总数的 4%，其中甚至包含一名联赛 344 分，排名浙江第 4，不出意外必然进入国家集训队的选手。这不禁让人联想，其中是不是有其它的利益关系呢？\nCCF 这样做并没有任何法律依据，而仅仅是搬出了 “ 国务院办公厅近日印发的《关于全面加强新时代语言文字工作的意见》指出，要“加强语言文明教育，强化对互联网等各类新媒体语言文字使用的规范和管理，坚决遏阻庸俗暴戾网络语言传播，建设健康文明的网络语言环境。” 这样一段并不具有法律效力的文本，就对 5 名选手做出了如此严厉的处罚。这种行为本就违反了中国科学技术协会发布的《中国科协全国五项学科竞赛条例》中 “ 不可擅自更改参赛学生的竞赛结果或成绩 ” 这一条款。 CCF 做出这样的事非但没有法律依据，并且还是在没有任何提前通知的情况下猝然做出的。这不禁让人忧心，如果今后某位选手在考完试后得罪了某位 CCF 的领导，那他是不是可以生造一条莫须有的规定来取消这位选手的成绩并将他禁赛呢？这未免太可怕了！ 因此，我作为一名现役的高二信息竞赛生，在此对 CCF 提出我们 OIer 的共同诉求 ：撤销对 5 名选手取消成绩和禁赛一年的处罚，将对它们的惩罚限定在批评教育的范畴内。如果贵学会坚持认为他们的行为对自己造成了严重的声誉影响，可以依法向他们提出合理的经济赔偿。\n我奉劝中国计算机学会，既然要承办信息学奥林匹克竞赛，那就要秉承奥林匹克精神，守住竞赛公平的底线，而不是成为用心险恶之人作恶的工具。\n作为一名中学生，我当然对改变此事无能为力。但 OIer 不是一名中学生，而是千千万万心怀公义的少年。若是 CCF 继续执迷不悟，非要一意孤行，将 OI 变成自己滥权和敛财的工具，那么必将被另一个更有能力的组织取代。事实上，我期待这一天的到来！\n最后我想说，国家交给任何组织的公权力都不是让其肆意滥用的，竞赛这种为国举才的大事不能用于满足某些人的私利，希望 CCF 悬崖勒马，不要陷自己于不仁不义不法之地。\n此致。\n下附信息学竞赛赛程和基本规则，以助不了解信息学竞赛者快速理解上文中某些内容 ：\n信息学竞赛的赛程是 ：\n初赛 +\u0026nbsp;CSP ：决定选手是否有资格参加 联赛 (NOIp)，允许社会人员参与。并且 CCF 曾宣布过 “ CSP 与 NOI 系列比赛没有任何关系” ，但最后还是成为了 NOIp 的预选赛，其真实目的也不过是为了对抗教育部 “ 竞赛不可收费 ” 的规定，违规收取选手的参赛费罢了。\nNOIp ：全国中学生信息联赛，对于一般选手来说这是一个赛季中最重要的比赛，将评出省一二三等奖，在 −OH 计划出台后已无实际作用，或许更大程度上是一个选手认真参加过 OI 的证明。\n省选 ：全国高中生信息竞赛省队选拔赛，用于选拔各省省队去参加 国赛 (NOI)，每个省的名额在 10 人左右，根据各省成绩好坏会有所增减。选拔方式为，将联赛和省选分数计算其占该省最高分比例后，分别以 0.4,0.6 的权重加权而得的值降序排列，从前往后取至省队名额。同时每所学校的进队人数不可占省队名额的 1/3 以上（四舍五入），因该限制而空出的名额向后顺延。\nNOI : 全国高中生信息竞赛，绝大多数顶尖选手的最终挑战，前 50 名进入国家集训队保送清北，51∼200 名获得银牌破格入围 −OH，除了这 200 人之外，无论获得其它什么奖项都仅作为纪念和荣誉，他们将带着对 OI 的回忆回归文化课。\n信息学竞赛的评分机制是 :\n初赛 ：笔试，题型为选择题和填空题，全部随机选择的期望分数可以晋级 CSP.\nCSP,NOIp\u0026nbsp;:\u0026nbsp;CSP\u0026nbsp;4 小时，NOIp\u0026nbsp;4.5 小时，均为 4 道题。\n省选，NOI ：均为两场，每场 5 小时，3 道题。\n除了初赛之外，考试中的每道题形如，给定一个问题，如 “ 给出两个数，求它们的和 ”，你需要在规定时间内编写一个程序用来解决它。考完之后选手编写的程序会被上交，统一进行评测。\n评测时评测机会给出一些输入文本，待测程序读取后会按照选手所编写的程式对其进行一定处理，然后给出输出文本。如果待测程序在规定时间内给出了输出文本，评测机会将它与标准答案进行对比，如果完全相同（也有一些非传统评测规则并非如此，此处略过）则选手获得该测试点的分数。比如说在之前那个问题中，评测机若给出输入文本 “ 2\u0026nbsp;3 ”，那么一个正确的程序应该输出 “ 5 ”，并且可以获得这个测试点的分数。\n在 OI 赛制中，每道题目的分数均为 100，最后每道题的得分之和就是一场考试的总分。当然，每道题的分数并不是非零即 100，大多数题目会给出若干子任务，如果选手无法解决完整的问题，可以选择一些弱化问题来解决，并获得相应的部分分。\n","date":"2022-07-20T21:37:26+08:00","permalink":"https://yhchank.github.io/p/%E8%BD%AC%E8%BD%BD%E4%B8%80%E5%B0%81%E9%9D%A2%E5%90%91%E7%A4%BE%E4%BC%9A%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%BF%91%E6%97%A5%E6%9D%A5-ccf-%E4%B8%8D%E5%BD%93%E8%A1%8C%E4%B8%BA%E4%B9%8B%E6%8A%97%E8%AE%AE%E7%9A%84%E5%85%AC%E5%BC%80%E4%BF%A1/","title":"【转载】一封面向社会，关于对近日来 CCF 不当行为之抗议的公开信"},{"content":"跳坑位置：P1005 [NOIP2007 提高组] 矩阵取数游戏\n此题数据范围：\n对于 60% 的数据，满足 1≤n,m≤30，答案不超过 1e16。 对于 100% 的数据，满足 1≤n,m≤80，0≤a[i][j]≤10000。\n区间dp很好想，但是根据数据范围，显然要用高精度 int128。 不过，写的时候要注意**「运算时的数据类型强制转换」**\n比如，如果写了表达式dp[l - 1][r] + a[i][l - 1] * p[m - r + l - 1]（其中dp和p为__int128，而a为int），那么计算时就会先将p[m - r + l - 1]转换为int再与a[i][l - 1]相乘\n所以，正确的写法是：dp[l - 1][r] + p[m - r + l - 1] * a[i][l - 1]（把目标类型写在运算符号前）\n","date":"2022-07-19T13:21:50+08:00","permalink":"https://yhchank.github.io/p/%E5%9D%91%E7%82%B9%E8%AE%B0%E5%BD%95%E5%85%B3%E4%BA%8E%E8%BF%9B%E8%A1%8C%E8%BF%90%E7%AE%97%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","title":"【坑点记录】关于进行运算时的数据类型转换"},{"content":"此处只记录链接，不转载了：请点击此处\n","date":"2022-07-18T13:26:30+08:00","permalink":"https://yhchank.github.io/p/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%AF%81%E6%98%8E--%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/","title":"树的重心相关概念与证明--好文摘录"},{"content":"1. 叶结点数最大 每个右子节点都为叶节点\n例如 【2015-NOIP-J-初赛-第22题】：\n一棵结点数为 2015 的二叉树最多有___个叶子结点。\n极端情况下，在二叉树中所有的右节点都是叶子节点，除最下层外的左节点都是父节点且有两个孩子，如图所示，1008 = 1007（3~2015的奇数个数)+1(2014)。\n1. 叶结点数最小 挂成一条链，则只有一个叶节点\n例如 【2016-NOIP-J-初赛-第22题】：\n约定二叉树的根节点高度为 1。一棵结点数为 2016 的二叉树最少有______个叶子结点\n形成一条链的情况，答案为1\n","date":"2022-07-17T12:03:53+08:00","permalink":"https://yhchank.github.io/p/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8A%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%80%BC/","title":"关于二叉树上叶节点的最值"},{"content":"出现的问题 计算组合数（公式如下）时，\n$$ C_{n}^{m}=\\frac{n!}{m!\\times(n-m)!} $$\n如果n很大，一般会要求将结果对某个数（比如 $1e9$ ）取模，显然 $n!$ 会非常大，可能 long long 都存不下，所以要一边乘，一边取模。数论中有三个式子\n$$ (a + b) % p = (a % p + b % p)%p $$\n$$ (a - b) % p = (a % p - b % p) % p $$\n$$ (a * b) % p = ((a % p) \\times (b % p)) % p $$\n但是对于除法却不成立，所以需要用逆元来解决\n简介 若$a \\times x % M = 1$，我们就称$x$是$a$的逆元，$x$可以写作$a^{-1}$次方（相当于整除中的倒数)\n用途 假设我们需要求$a \\div b % M$的值，而由于上述种种原因，我们不能直接除，这时就可以对式子进行一些操作:\n$$ a \\div b % M = a \\div b \\times 1 % M = a \\div b \\times (b \\times b^{-1}) % M = a \\times b^{-1} % M $$\n注意：\n上式中的$b$的$-1$次方指的是b的逆元 第三步变形的依据是：$b \\times b^{-1} % M = 1$（这是第一行的定义） 现在就已经把除法转换为了乘法，可以正常计算了\n怎么求逆元 怎么求一个数的逆元呢？\n首先，要求一个数的逆元，需要两个元素，这个数（$a$）和模数（$M$）\n$$ a \\times a^{-1} % M = 1 $$\n根据费马小定理（$a^{p - 1} \\equiv 1\\pmod p$）可得（$M$须为质数）：\n$$ a^{-1} = a^{M - 2}（这里要用到快速幂） $$\n可以求逆元了，那怎么求阶乘的逆元呢？\n可以根据性质$inv[i] = (M - M \\div i) \\times inv[M % i] % M(inv[1] = 1)$顺着求出每个数的逆元然后再把每个数的inv乘起来，得到阶乘的逆元\n可以从后往前推：\n若$n!$的逆元 $= k$ 即$n! \\times k % M = 1$ 因为$n - 1! = n! \\div n$， $n! \\div n \\times k \\times n % M = 1$ 所以$(n - 1)!$的逆元等于$k \\times n$，\n可以先正推求出$fac[i]$（$i$的阶乘），再通过费马小定理算出$inv[n]$（和上面不同，这里是指$n!$的逆元），最后倒推求出所有的$inv[i]$\n","date":"2022-02-17T20:14:43+08:00","permalink":"https://yhchank.github.io/p/%E9%80%86%E5%85%83/","title":"逆元"}]